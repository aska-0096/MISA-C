#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <fstream>
#include <functional>

#include "amdgpu.h"
#include "macro.h"

#define MC_DEBUG_IGNORE_LDS_IO  false
#define MC_DEBUG_IGNORE_GLOBAL_IO  false

// C++ equivalent of Python string split
std::vector<std::string> split(const std::string str, const std::string regex_str)
{
    std::regex regexz(regex_str);
    std::vector<std::string> list(std::sregex_token_iterator(str.begin(), str.end(), regexz, -1),
                                  std::sregex_token_iterator());
    return list;
}

class _mc_indent_context_manager_t{
public:
    _mc_indent_context_manager_t(_mc_indent_t& indent_,
                                 const std::function<void()> &enter_func_=NULL,
                                 const std::function<void()> &exit_func_=NULL)
                                 : indent( &indent_), enter_func(enter_func_), exit_func(exit_func_){
                                    if(enter_func)
                                        enter_func();
                                    if(indent)
                                        indent->inc();                                   
                                 }
    ~_mc_indent_context_manager_t(){
        if(indent)
            indent->inc();
        if(exit_func)
            exit_func();
    }
private:
    _mc_indent_t* indent;
    std::function<void()> enter_func;
    std::function<void()> exit_func;
};
class _mc_indent_t{
public:
    _mc_indent_t(const int& indent_size_per_level_,
                 const char& indent_char_ = ' ')
                 : indent_size_per_level(indent_size_per_level_), level(0), indent_char(indent_char_), indent(""){}
    
    std::string operator()(){
        return indent;
    }

    void _update_indent(){
        indent = "";
        for(int i = 0; i< indent_size_per_level * level; i++)
            indent +=indent_char;
    }

    void inc(){
        level++;
        _update_indent();
    }

    void dec(){
        if (level > 0) level--;
        _update_indent();
    }

    void set(int level_){
        level = level_;
        _update_indent();
    }

    int get(){
        return level;
    }
private:
    int indent_size_per_level;
    int level;
    char indent_char;
    std::string indent;
};

class mc_emit_to_file_t{
public:
    mc_emit_to_file_t(const std::string& file_name_,
                      _mc_indent_t indent_ = _mc_indent_t(4))
                      : file_name(file_name_), current_file(nullptr), indent(indent_){}
    
    ~mc_emit_to_file_t(){
        close();
    }

    void open(){
        if(current_file == nullptr){
        // TODO which mode?
            try
            {
                current_file->open(file_name);
            }
            catch(const std::exception& e)
            {
                std::cerr << e.what() << '\n';
            }

            emit_license();
            // emit('; generated by igemm_codegen.py ({})'.format(mc_get_version()));
            emit(";");

            // TODO Is flush equivalent with fsync?
            current_file->flush();
            // os.fsync(self.f);
        }
    }

    void emit(const std::string& instruction){
        if(current_file){
            if (MC_DEBUG_IGNORE_LDS_IO || MC_DEBUG_IGNORE_GLOBAL_IO){
                auto s2 = split(instruction, "\n");
                std::vector<std::string> ignore_list;
                if(MC_DEBUG_IGNORE_LDS_IO){
                    ignore_list.insert(end(ignore_list), {"ds_read", "ds_write", "s_barrier"});
                }
                if (MC_DEBUG_IGNORE_GLOBAL_IO){
                    ignore_list.insert(end(ignore_list), {"buffer_load", "s_waitcnt"});
                }

                for(int i = 0; i<s2.size(); i++){
                    bool need_emit = true;
                    for(auto ignore: ignore_list){
                        if(s2[i].find(ignore)!=std::string::npos){
                            need_emit = false;
                            break;
                        }
                    }
                    if(need_emit){
                        i == 0 ?
                        *current_file << (indent() + s2[i] + "\n") :
                        *current_file << ("" + s2[i] + "\n");
                    }
                }
            }
            else
                *current_file << (indent() + instruction + "\n");
        }
    }

    void emit_license(){
        emit("/*******************************************************************************");
        emit(" *");
        emit(" * MIT License");
        emit(" *");
        emit(" * Copyright (c) 2020-2021 Advanced Micro Devices, Inc.");
        emit(" *");
        emit(" * Permission is hereby granted, free of charge, to any person obtaining a copy");
        emit(" * of this software and associated documentation files (the \"Software\"), to deal");
        emit(" * in the Software without restriction, including without limitation the rights");
        emit(" * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell");
        emit(" * copies of the Software, and to permit persons to whom the Software is");
        emit(" * furnished to do so, subject to the following conditions:");
        emit(" *");
        emit(" * The above copyright notice and this permission notice shall be included in all");
        emit(" * copies or substantial portions of the Software.");
        emit(" *");
        emit(" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR");
        emit(" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,");
        emit(" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE");
        emit(" * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER");
        emit(" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,");
        emit(" * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE");
        emit(" * SOFTWARE.");
        emit(" *");
        emit(" *******************************************************************************/");
    }

    void close(){
        if(current_file){
            current_file->close();
            close();
        }
        current_file = nullptr;
    }

    _mc_indent_context_manager_t indent_context(const std::function<void()> &enter_func=NULL, const std::function<void()> &exit_func=NULL){
        return _mc_indent_context_manager_t(indent, enter_func, exit_func);
    }

    void inc_indent(){
        indent.inc();
    }
    void dec_indent(){
        indent.dec();
    }
    void set_indent(int level){
        indent.set(level);
    }
    int get_indent(){
        return indent.get();
    }

private:    
    std::string file_name;
    std::ofstream* current_file;
    _mc_indent_t indent;
};

class mc_asm_printer_t{
public:
    mc_asm_printer_t(const mc_emit_to_file_t &emitter_,
                     const amdgpu_arch_config_t &arch_config_)
    : emitter(emitter_), arch_config(arch_config_){
        emitter.open();
        // IDLE global_bucket not used.
        // global_bucket = set()
    }

    ~mc_asm_printer_t(){
        emitter.close();
    }

    void insert_unique(const std::string& name,
                       const macro_base_t& macro){
        // FIXME Only support macro type mc
        if(unique_emitter_dict.find(name) == unique_emitter_dict.end())
            unique_emitter_dict.insert({name, macro});
    }

    void emit_all_unique(){
        // TODO Sort by name
        for(auto& macro_emitter : unique_emitter_dict){
            macro_emitter.second.emit();
        }
    }

    void emit(const std::string& instruction){
        emitter.emit(instruction);
    }

    void emit_empty_line(){
        int indent_level = emitter.get_indent();
        emitter.set_indent(0);
        emitter.emit("");
        emitter.set_indent(indent_level);
    }

    _mc_indent_context_manager_t indent_context(const std::function<void()> &enter_func=NULL,
                                                const std::function<void()> &exit_func=NULL){
        return emitter.indent_context(enter_func, exit_func);
    }

    _mc_indent_context_manager_t emit_macro_indented(const std::string& macro_define_str){
        void macro_enter(){
            emit("macro_define_str");
        }
        void macro_exit(){
            emit(".endm");
            emit_empty_line();
        }
        return indent_context(macro_enter, macro_exit);
    }

    void emit_macro_desc()



private:
    mc_emit_to_file_t emitter;
    amdgpu_arch_config_t arch_config;
    std::string deferred_buffer = "";
    std::unordered_map<std::string, macro_base_t> unique_emitter_dict;
};

class mc_base_t
{
public:
    mc_base_t(const mc_asm_printer_t& mc_) : mc(mc_){
        mc.inject();
    }
private:
    mc_asm_printer_t mc;
};

class mc_asm_printer_t(object):
    '''
    this is the MC
    '''
    def __init__(self, emitter, arch_config):
        self.emitter = emitter
        self.emitter.open()
        self.deferred_buffer = ''
        self.global_bucket = set()          # for uniqueness
        self.unique_emitter_dict = dict()
        self.arch_config = arch_config

    def __del__(self):
        self.emitter.close()
    
    def close(self):
        self.emitter.close()

    def insert_unique(self, k, v):
        # TODO: better check valid emitter
        assert type(k) is str
        assert hasattr(v, 'emit'), 'insert a object must have attribute "emit()"!'
        if k not in self.unique_emitter_dict:
            self.unique_emitter_dict[k] = v

    def emit_all_unique(self):
        # Note! sort by name here!
        for k, v in sorted(self.unique_emitter_dict.items()):
            v.emit()

    def emit(self, s):
        self.emitter.emit(s)

    def emit_empty_line(self):
        indent_level = self.emitter.get_indent()
        self.emitter.set_indent(0)
        self.emitter.emit('')
        self.emitter.set_indent(indent_level)

    def emit_macro_indented(self, macro_define_str):
        def macro_enter():
            self.emit(macro_define_str)
        def macro_exit():
            self.emit('.endm')
            self.emit_empty_line()
        return self.indent_context(macro_enter, macro_exit)

    def emit_macro_desc(self, *misc):
        self.emit('; ' + ' '.join( '{}'.format(e) for e in misc))

    def emit_front(self, s):
        indent_level = self.emitter.get_indent()
        self.emitter.set_indent(0)
        self.emitter.emit(s)
        self.emitter.set_indent(indent_level)

    def inc_indent(self):
        self.emitter.inc_indent()
    def dec_indent(self):
        self.emitter.dec_indent()
    def indent_context(self,enter_func=None, exit_func=None):
        return self.emitter.indent_context(enter_func,exit_func)

    def deferred_context(self):
        class deferred_context_t(object):
            def __init__(self, outter):
                self.outter = outter
                self.original_emitter = outter.emitter
                self.deferred_emitter = mc_deferred_emit_t(self.original_emitter)
            def __enter__(self):
                self.outter.emitter = self.deferred_emitter
            def __exit__(self, type, value, traceback):
                self.outter.emitter = self.original_emitter
                self.outter.deferred_buffer = self.deferred_emitter.get_buffer()
        return deferred_context_t(self)

    def get_deferred(self):
        return self.deferred_buffer

    def inject(self, other):
        '''
        useful to inject some control func here
        '''
        #def _emit_unique_wrapper():
        #    self.emit_unique(other)
        def _macro_desc_wrapper(*misc):
            self.emit_macro_desc(inspect.cleandoc(other.__doc__), *misc)
        other._emit = self.emit
        other._emit_empty_line = self.emit_empty_line
        other._emit_macro_indented = self.emit_macro_indented
        other._emit_macro_desc = _macro_desc_wrapper
        other._emit_front = self.emit_front
        #other._emit_unique = _emit_unique_wrapper
        other._inc_indent = self.inc_indent
        other._dec_indent = self.dec_indent
        other._indent_context = self.indent_context
        other._deferred_context = self.deferred_context
        other._get_deferred = self.get_deferred
        other._insert_unique = self.insert_unique